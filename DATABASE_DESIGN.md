# Moneybags Database Design

## Overview

Moneybags uses **MariaDB** as the database engine, running in a separate Docker container from the application. The database design prioritizes data integrity, performance for htmx-driven interactions, and connection resilience.

**ORM:** All database interactions use **PeeWee ORM**. Models are defined in `database_model.py`, and all CRUD operations in `database_manager.py` use PeeWee's query interface.

## Architecture Principles

### 1. No Logic in Database
- All business logic resides in `business_logic.py`
- All constraints and validation enforced in backend code, not database
- Database is a pure data store

### 2. Connection Management
- MariaDB runs in separate Docker container
- Connection pooling for performance (htmx requires fast responses)
- Graceful handling of connection drops
- Transaction management to prevent data loss
- All database interactions through `database_manager.py`

### 3. Data Types & Value Assignment
- **UUIDs**: Generated in `business_logic.py` via `utils.generate_uid()` before saving
- **Integers**: All currency amounts (no decimals/floats)
- **Dates/Timestamps**: Set in `business_logic.py` in YYYY-MM-DD HH:MM:SS format (24-hour)
- **NULL handling**: Empty strings converted to NULL via `utils.empty_to_none()` in `business_logic.py`
- **All defaults**: Set explicitly in `business_logic.py`, not in models or database

---

## Database Schema

**Note:** The SQL statements below are for reference only. All models will be implemented using **PeeWee ORM** in `database_model.py`. See the "PeeWee Model Definitions" section at the end of this document for implementation details.

### 1. Categories

Stores income and expense categories. Categories are global across all years.

```sql
CREATE TABLE categories (
    id VARCHAR(10) PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    type ENUM('income', 'expenses') NOT NULL,
    created_at DATETIME NOT NULL,
    UNIQUE KEY unique_category_name (name)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

**Fields:**
- `id`: UUID generated by `utils.generate_uid()`
- `name`: Category name (globally unique)
- `type`: Either 'income' or 'expenses'
- `created_at`: Timestamp when created

**Business Rules (enforced in business_logic.py):**
- Category names must be globally unique (case-insensitive comparison)
- Cannot delete category if referenced by budget_entries or transactions
- Cannot change category type if data exists

**Indexes:**
- Primary key on `id`
- Unique index on `name`

---

### 2. Payees

Stores payees that appear in transactions.

```sql
CREATE TABLE payees (
    id VARCHAR(10) PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    type ENUM('Generic', 'Actual') NOT NULL DEFAULT 'Actual',
    created_at DATETIME NOT NULL,
    UNIQUE KEY unique_payee_name (name)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

**Fields:**
- `id`: UUID generated by `utils.generate_uid()`
- `name`: Payee name (globally unique)
- `type`: 'Generic' (e.g., "Hairdresser") or 'Actual' (e.g., "Bad Hairday Ltd")
- `created_at`: Timestamp when created

**Business Rules (enforced in business_logic.py):**
- Payee names must be globally unique (case-insensitive comparison)
- Cannot delete payee if referenced by transactions
- Renaming a payee updates all associated transactions

**Indexes:**
- Primary key on `id`
- Unique index on `name`

---

### 3. Budget Templates

Defines which categories are active/visible for each year's budget.

```sql
CREATE TABLE budget_templates (
    id VARCHAR(10) PRIMARY KEY,
    year INT NOT NULL,
    category_id VARCHAR(10) NOT NULL,
    created_at DATETIME NOT NULL,
    KEY idx_year (year),
    KEY idx_category_id (category_id),
    FOREIGN KEY (category_id) REFERENCES categories(id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

**Fields:**
- `id`: UUID generated by `utils.generate_uid()`
- `year`: Calendar year (e.g., 2025)
- `category_id`: Foreign key to categories table
- `created_at`: Timestamp when created

**Business Rules (enforced in business_logic.py):**
- Unique constraint on (year, category_id) - no duplicates
- Only categories in budget_templates are shown in budget view for that year
- User can copy previous year's template when creating a new year
- User can add/remove categories from a year's template

**Indexes:**
- Primary key on `id`
- Index on `year` for filtering
- Index on `category_id` for joins
- Foreign key to `categories(id)`

---

### 4. Budget Entries

Stores budget amounts for each category, year, and month.

```sql
CREATE TABLE budget_entries (
    id VARCHAR(10) PRIMARY KEY,
    category_id VARCHAR(10) NOT NULL,
    year INT NOT NULL,
    month TINYINT NOT NULL,
    amount INT NOT NULL DEFAULT 0,
    created_at DATETIME NOT NULL,
    updated_at DATETIME NOT NULL,
    KEY idx_category_year_month (category_id, year, month),
    FOREIGN KEY (category_id) REFERENCES categories(id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

**Fields:**
- `id`: UUID generated by `utils.generate_uid()`
- `category_id`: Foreign key to categories table
- `year`: Calendar year (integer, e.g., 2025)
- `month`: Month number (1-12)
- `amount`: Budget amount in integer (e.g., 53000 = 53000 kr)
- `created_at`: Timestamp when created
- `updated_at`: Timestamp when last modified

**Business Rules (enforced in business_logic.py):**
- Unique constraint on (category_id, year, month) - one budget per category per month
- Month must be 1-12
- Amount stored as integer (no decimals)
- Cannot create budget entry for category not in budget_templates for that year

**Indexes:**
- Primary key on `id`
- Composite index on `(category_id, year, month)` for fast lookups
- Foreign key to `categories(id)`

---

### 5. Transactions

Stores actual income and expense transactions.

```sql
CREATE TABLE transactions (
    id VARCHAR(10) PRIMARY KEY,
    category_id VARCHAR(10) NOT NULL,
    payee_id VARCHAR(10) NULL,
    date DATE NOT NULL,
    amount INT NOT NULL,
    comment TEXT NULL,
    created_at DATETIME NOT NULL,
    updated_at DATETIME NOT NULL,
    KEY idx_category_id (category_id),
    KEY idx_payee_id (payee_id),
    KEY idx_date (date),
    FOREIGN KEY (category_id) REFERENCES categories(id),
    FOREIGN KEY (payee_id) REFERENCES payees(id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

**Fields:**
- `id`: UUID generated by `utils.generate_uid()`
- `category_id`: Foreign key to categories table
- `payee_id`: Foreign key to payees table (nullable)
- `date`: Transaction date (YYYY-MM-DD)
- `amount`: Transaction amount in integer
- `comment`: Optional comment (nullable)
- `created_at`: Timestamp when created
- `updated_at`: Timestamp when last modified

**Business Rules (enforced in business_logic.py):**
- Amount stored as integer (no decimals)
- Payee is optional; empty values stored as NULL
- Comment is optional; empty strings converted to NULL via `utils.empty_to_none()`
- Year/month derived from date column (not denormalized)

**Indexes:**
- Primary key on `id`
- Index on `category_id` for filtering
- Index on `payee_id` for filtering
- Index on `date` for date-range queries
- Foreign keys to `categories(id)` and `payees(id)`

---

### 6. Configuration

Stores application configuration including database connection parameters.

```sql
CREATE TABLE configuration (
    id VARCHAR(10) PRIMARY KEY,
    key VARCHAR(255) NOT NULL,
    value TEXT NOT NULL,
    created_at DATETIME NOT NULL,
    updated_at DATETIME NOT NULL,
    UNIQUE KEY unique_config_key (key)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

**Fields:**
- `id`: UUID generated by `utils.generate_uid()`
- `key`: Configuration key (e.g., "currency_format", "db_host")
- `value`: Configuration value (can be JSON for complex values)
- `created_at`: Timestamp when created
- `updated_at`: Timestamp when last modified

**Configuration Keys:**
- `currency_format`: "nok", "usd", "eur"
- `db_host`: MariaDB host (e.g., "mariadb" for Docker container name)
- `db_port`: MariaDB port (default: 3306)
- `db_name`: Database name
- `db_user`: Database username
- `db_password`: Database password (encrypted/hashed in production)
- `db_pool_size`: Connection pool size (default: 10)
- `db_pool_recycle`: Connection recycle time in seconds (default: 3600)

**Business Rules (enforced in business_logic.py):**
- Keys must be unique
- Database connection settings managed via Configuration page UI
- Validation for specific key formats

**Indexes:**
- Primary key on `id`
- Unique index on `key`

---

## Database Connection Architecture

### Connection Manager (`database_manager.py`)

The `database_manager.py` module handles all database interactions and manages connections efficiently for htmx performance requirements.

#### Responsibilities:

1. **Connection Pooling**
   - Initialize connection pool on application startup
   - Pool size configurable via `configuration` table
   - Reuse connections for multiple requests
   - Automatic connection recycling to prevent stale connections

2. **Connection Resilience**
   - Retry logic for transient connection failures
   - Graceful degradation if database unavailable
   - Connection health checks before queries
   - Automatic reconnection on connection drop

3. **Transaction Management**
   - All write operations wrapped in transactions
   - Automatic rollback on errors
   - Commit only on successful completion
   - Prevent partial writes and data corruption

4. **CRUD Operations**
   - All database interactions go through database_manager
   - No direct database calls from business_logic or main
   - Consistent error handling across all operations
   - Query optimization for htmx speed requirements

#### Connection Pool Configuration:

```python
# Example configuration loaded from database
POOL_CONFIG = {
    'host': 'mariadb',  # Docker container name
    'port': 3306,
    'database': 'moneybags',
    'user': 'moneybags_user',
    'password': '********',
    'pool_size': 10,
    'pool_recycle': 3600,  # Recycle connections every hour
    'pool_pre_ping': True,  # Verify connection before using
}
```

#### Transaction Pattern:

```python
# All writes follow this pattern
def create_transaction(category_id, date, amount, payee_id=None, comment=None):
    try:
        # Begin transaction
        # Insert record
        # Commit
        return success_response
    except Exception as e:
        # Rollback
        # Log error
        return error_response
```

---

## Configuration Page - Database Settings

### New Section: Database Connection

Add section to `/templates/config.html` for managing database connection:

**UI Elements:**
- Database Host (text input)
- Database Port (number input, default: 3306)
- Database Name (text input)
- Database Username (text input)
- Database Password (password input)
- Connection Pool Size (number input, default: 10)
- Test Connection button
- Save button

**Behavior:**
- Settings stored in `configuration` table
- Test Connection validates before saving
- Changes require application restart (or connection pool reload)
- Show connection status indicator (connected/disconnected)

### New Section: Annual Budget Templates

Add section to `/templates/config.html` for managing which categories appear in each year:

**UI Elements:**
- Expandable accordion showing each year
- For each year:
  - List of active categories with remove buttons
  - "Add Category" dropdown to add from available categories
  - "Add New Year" button
  - "Copy from Previous Year" checkbox when adding new year

**Behavior:**
- Load budget_templates for each year
- Add/remove creates/deletes budget_templates records
- Creating new year optionally copies previous year's template
- Cannot remove category if budget_entries or transactions exist for that year

---

## Data Integrity Rules

All enforced in `business_logic.py`:

### Referential Integrity

1. **Categories:**
   - Cannot delete if referenced by budget_templates, budget_entries, or transactions
   - Renaming updates category name globally

2. **Payees:**
   - Cannot delete if referenced by transactions
   - Renaming updates all transaction references

3. **Budget Templates:**
   - category_id must exist in categories table
   - Unique (year, category_id) combination

4. **Budget Entries:**
   - category_id must exist in categories table
   - Category must exist in budget_templates for that year
   - Unique (category_id, year, month) combination
   - Month must be 1-12

5. **Transactions:**
   - category_id must exist in categories table
   - payee_id must exist in payees table (if not NULL)
   - Date must be valid

### NULL Handling

- All empty strings converted to NULL via `utils.empty_to_none()`
- Apply to: payee_id, comment fields
- Never store "" or blank strings

### Uniqueness

- Category names: globally unique (case-insensitive)
- Payee names: globally unique (case-insensitive)
- Configuration keys: unique
- (category_id, year, month) in budget_entries: unique
- (year, category_id) in budget_templates: unique

---

## Performance Considerations

### For htmx Fast Responses

1. **Connection Pooling:** Reuse connections, avoid overhead of creating new connections
2. **Indexes:** Strategic indexes on foreign keys and frequently queried columns
3. **Query Optimization:** Fetch only needed columns, use JOINs efficiently
4. **Caching:** Consider caching configuration table in memory
5. **Lazy Loading:** Load data on-demand for specific years/months

### Container Architecture

```
┌─────────────────┐         ┌─────────────────┐
│   App Container │────────▶│ MariaDB Container│
│   (FastAPI)     │         │   (Database)     │
│   Port: 8009    │         │   Port: 3306     │
└─────────────────┘         └─────────────────┘
```

**Network:**
- Containers communicate via Docker network
- Low latency (same host)
- Connection pooling critical for performance

---

## Migration Notes

### Initial Setup

1. Create database and user in MariaDB
2. Run schema creation SQL scripts
3. Initialize configuration table with default values
4. Create initial categories (optional seed data)
5. Test connection from application

### Future Migrations

- Track schema changes in separate migration files
- Version control for database schema
- Backup before migrations
- Test migrations on development environment first

---

## Security Considerations

1. **Database Credentials:**
   - Store encrypted in configuration table
   - Never commit credentials to git
   - Use environment variables for initial bootstrap

2. **SQL Injection Prevention:**
   - PeeWee ORM handles parameterization
   - Never construct raw SQL with string concatenation

3. **Access Control:**
   - Database user has minimal required permissions
   - No DROP/ALTER permissions in production

4. **Connection Security:**
   - Use SSL/TLS for production database connections
   - Firewall rules to restrict database access

---

## PeeWee Model Definitions

All models are defined in `database_model.py` using PeeWee ORM. Models are **pure data structures** with NO logic - all field values set by `business_logic.py` before passing to `database_manager.py`.

```python
from peewee import *

# Database connection initialized in database_manager.py
database = MySQLDatabase(None)

class BaseModel(Model):
    """Base model with common fields - NO LOGIC."""
    id = CharField(primary_key=True, max_length=10)  # Set by business_logic.py
    created_at = DateTimeField()  # Set by business_logic.py

    class Meta:
        database = database

class Category(BaseModel):
    """Income and expense categories."""
    name = CharField(max_length=255, unique=True)
    type = CharField(max_length=10)  # 'income' or 'expenses'

    class Meta:
        table_name = 'categories'

class Payee(BaseModel):
    """Payees that appear in transactions."""
    name = CharField(max_length=255, unique=True)
    type = CharField(max_length=10)  # 'Generic' or 'Actual' - set by business_logic.py

    class Meta:
        table_name = 'payees'

class BudgetTemplate(BaseModel):
    """Defines which categories are active for each year."""
    year = IntegerField()
    category_id = ForeignKeyField(Category, column_name='category_id')

    class Meta:
        table_name = 'budget_templates'
        indexes = (
            (('year', 'category_id'), False),
        )

class BudgetEntry(BaseModel):
    """Budget amounts for each category, year, and month."""
    category_id = ForeignKeyField(Category, column_name='category_id')
    year = IntegerField()
    month = SmallIntegerField()
    amount = IntegerField()  # No default - set by business_logic.py
    updated_at = DateTimeField()  # Set by business_logic.py

    class Meta:
        table_name = 'budget_entries'
        indexes = (
            (('category_id', 'year', 'month'), False),
        )

class Transaction(BaseModel):
    """Actual income and expense transactions."""
    category_id = ForeignKeyField(Category, column_name='category_id')
    payee_id = ForeignKeyField(Payee, column_name='payee_id', null=True)
    date = DateField()
    amount = IntegerField()
    comment = TextField(null=True)
    updated_at = DateTimeField()  # Set by business_logic.py

    class Meta:
        table_name = 'transactions'
        indexes = (
            (('category_id',), False),
            (('payee_id',), False),
            (('date',), False),
        )

class Configuration(BaseModel):
    """Application configuration settings."""
    key = CharField(max_length=255, unique=True)
    value = TextField()
    updated_at = DateTimeField()  # Set by business_logic.py

    class Meta:
        table_name = 'configuration'
```

### Key PeeWee Patterns

**1. Model Definition:**
- All models inherit from `BaseModel`
- Models are **pure data structures** - NO logic, NO defaults, NO save() overrides
- All field values set explicitly by `business_logic.py`

**2. Foreign Keys:**
- Use `ForeignKeyField` for relationships
- Explicit `column_name` parameter for clarity (`category_id`, `payee_id`)
- **NO on_delete parameters** - all deletion/update logic in `business_logic.py`
- **NO backref parameters** - models are pure data, all queries explicit in `database_manager.py`
- `null=True` for optional relationships only (payee)

**3. Indexes:**
- Define in `Meta` class using `indexes` tuple
- Composite indexes for multi-column lookups

**4. Database Connection:**
- Initialize in `database_manager.py`
- Connection pooling handled by PeeWee's connection pool
- Database instance shared across all models

**5. Field Value Assignment (business_logic.py responsibilities):**
- `id`: Generate via `utils.generate_uid()` before create
- `created_at`: Set to `datetime.now()` before create
- `updated_at`: Set to `datetime.now()` before create/update
- Defaults: Set explicitly (e.g., `amount=0` if not provided)
- NULL conversion: Use `utils.empty_to_none()` for optional fields

### Usage Pattern: business_logic.py → database_manager.py

**business_logic.py prepares complete data:**
```python
from datetime import datetime
from utils import generate_uid, empty_to_none
import database_manager as db

def create_category(name, type):
    """Business logic: validate and create category."""
    # Validation
    if not name or not type:
        raise ValueError("Name and type required")
    if type not in ['income', 'expenses']:
        raise ValueError("Invalid type")

    # Check uniqueness (business_logic.py checks before attempting insert)
    if db.category_exists(name):
        raise ValueError("Category already exists")

    # Prepare complete record with all fields
    category_data = {
        'id': generate_uid(),
        'name': name,
        'type': type,
        'created_at': datetime.now()
    }

    # Pass to database_manager
    return db.create_category(category_data)

def create_transaction(category_id, date, amount, payee_id=None, comment=None):
    """Business logic: validate and create transaction."""
    # Validation
    if not category_id or not date or amount is None:
        raise ValueError("Required fields missing")

    # Prepare complete record with explicit field names matching model
    transaction_data = {
        'id': generate_uid(),
        'category_id': category_id,  # Explicit _id suffix matches model field
        'payee_id': empty_to_none(payee_id),  # Convert empty to NULL
        'date': date,
        'amount': amount,
        'comment': empty_to_none(comment),  # Convert empty to NULL
        'created_at': datetime.now(),
        'updated_at': datetime.now()
    }

    # Pass to database_manager
    return db.create_transaction(transaction_data)
```

**database_manager.py performs pure CRUD:**
```python
from database_model import Category, Transaction

def create_category(data):
    """Pure CRUD: create category with provided data."""
    category = Category(**data)
    category.save()
    return category

def category_exists(name):
    """Pure CRUD: check if category exists."""
    return Category.select().where(Category.name == name).exists()

def create_transaction(data):
    """Pure CRUD: create transaction with provided data."""
    transaction = Transaction(**data)
    transaction.save()
    return transaction

def get_budget_entry(category_id, year, month):
    """Pure CRUD: get budget entry."""
    try:
        return BudgetEntry.get(
            (BudgetEntry.category_id == category_id) &
            (BudgetEntry.year == year) &
            (BudgetEntry.month == month)
        )
    except BudgetEntry.DoesNotExist:
        return None
```

**All CRUD operations in `database_manager.py` use PeeWee's ORM methods:**
- `Model.create()` for inserts
- `Model.save()` for updates
- `Model.get()` / `Model.select()` for queries
- `Model.delete_instance()` for deletes
- Query building with PeeWee's expressive syntax

---

## Summary

This design provides:
- ✅ Clear separation of concerns (no DB logic)
- ✅ Data integrity through business_logic enforcement
- ✅ Performance for htmx interactions via connection pooling
- ✅ Resilience to connection drops
- ✅ Flexible multi-year budget management via budget_templates
- ✅ User-configurable database connection
- ✅ Integer-based currency (no float precision issues)
- ✅ Consistent NULL handling
- ✅ Global category/payee management with usage tracking
